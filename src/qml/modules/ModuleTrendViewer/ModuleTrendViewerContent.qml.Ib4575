import QtQuick 2.7
import QtQuick.Controls 2.1
import "../"

Canvas {
    id: root

    property real contentX : width * 0.05
    property real contentY : height * 0.05
    property real contentWidth : width * 0.8
    property real contentHeight : height * 0.8
    property var  trendSettings: settings

    Item{
        //private
        id:__
        property int  gridSize: 4
        property real gridStep: gridSize ? (width - root.tickMargin) / gridSize : root.xGridStep
        property int  pixelSkip: 1
        property int  numPoints: 1
        property int  tickMargin: 34
        property real xGridStep: (width - tickMargin) / numPoints
        property real yGridOffset: height / 26
        property real yGridStep: height / 12

        property bool autoUpdate: false//when time is close to currentTime

        readonly property int  dataDensity: 100 //points in one screen

        property var  y1trendModel
        property var  y2trendModel
        property var  y3trendModel
        property var  y4trendModel

        property var dateStart__MS :-1 //ms int
        property var dateStop__MS  :-1  //ms int
        property real xRatio : 1.0

        function updateAxisXConfig(addOffsetX,addRatio,originX){
            //update axis X's config
            var now = Date().getTime()
            var oldSpan = trendSettings.xSpan__MS * xRatio
            //init
            if(dateStart__MS === -1){
                dateStop__MS = Math.min((trendSettings.dateStart.getTime() + oldSpan), now )
                dateStart__MS = dateStop__MS - oldSpan
            }
            //add
            var xPixelLength = root.contentWidth
            var addOffsetTime = addOffsetX / xPixelLength * oldSpan

            var offSetDate = referSpanDate
            var referdateStop__MS = Math.min(trendSettings.dateStart + trendSettings.xSpan__MS, now  )
            var actualSpan = referSpanDate * multiTouchX.ratio
            if(multiTouchX.state === 1){
                //moving
                var actualOffset = (multiTouchX.offsetX / contentWidth) * actualSpan
                var newEndDate = dateStart__MS

            }else{
                //scale
                var centerXTime = (multiTouchX.originX / contentWidth) * lastTimeSpan + dateStart__MS
                var oldRatio = lastTimeSpan / trendSettings.xSpan__MS
                dateStart__MS = (centerXTime - dateStart__MS) / oldRatio * multiTouchX.ratio
            }

            timespan = trendSettings.xSpan__MS * multiTouchX.ratio
        }
        function updateAxisYConfig(){

        }

        function drawCurrentDate(x){

        }


    }

    ModuleTrendSettings{id:settings}
    //using 3 areas, for X-axis scale, Y-axis scale and current Date
    //selection respectively.
    ModuleMultiTouch{
        id: multiTouchX
        x: 0
        y: contentHeight
        width: contentWidth
        height: root.height - contentHeight
        onUpdateChanging: {
            __.updateAxisXConfig(addOffsetX,addRatio,originX)
        }
    }
    ModuleMultiTouch{
        id: multiTouchY
        x: contentWidth
        y: 0
        width: root.width - contentWidth
        height: root.height
        onUpdateChanging: {
            __.updateAxisYConfig()
        }
    }
    MouseArea{
        id: singleClickArea
        x:0
        y:0
        width: contentWidth
        height: contentHeight
        onClicked: {
            __.drawCurrentDate(mouseX)
        }
    }

    Connections{
        target: settings
        onXSpan__MSChanged:{
            //  改变密度: 1.清空所有曲线缓存 2.初始化y轴移动 3.重算密度并查询 4.重新绘图
            dataSource.clearAllHistoryTags()
            yRatio = 1.0
            yOffset = 0.0
        }
        onDateStartChanged:{
        }

        onUpdateInterv__MSChanged:{
            checkForAutoUpdate.interval = settings.updateInterv__MS
        }
    }

    Timer{
        id: checkForAutoUpdate
        running: true
        interval: 5000
        repeat: true
        onTriggered: {
            autoUpdateProcess()
        }
    }

    // Uncomment below lines to use OpenGL hardware accelerated rendering.
    // See Canvas documentation for available options.
    // renderTarget: root.FramebufferObject
    // renderStrategy: root.Threaded
    function autoUpdateProcess(){
        var nowDate
        nowDate = new Date()
        if( Math.abs(settings.dateStart.getTime() - nowDate.getTime()) <= 1000){
            //autoUpdate
            autoUpdate = true
            settings.dateStart = nowDate

        }else{
            autoUpdate = false
        }
    }

    function drawBackground(ctx){
        ctx.save();
        ctx.fillStyle = "#ffffff";//设置或返回用于填充绘画的颜色、渐变或模式
        ctx.fillRect(0, 0, root.width, root.height);//绘制“被填充”的矩形
        ctx.strokeStyle = "#d7d7d7";//设置或返回用于笔触的颜色、渐变或模式
        ctx.beginPath();//起始一条路径，或重置当前路径
        // Horizontal grid lines
        for (var i = 0; i < 12; i++) {
            ctx.moveTo(0, root.yGridOffset + i * root.yGridStep);//把路径移动到画布中的指定点，不创建线条
            ctx.lineTo(root.width, root.yGridOffset + i * root.yGridStep);//添加一个新点，然后在画布中创建从该点到最后指定点的线条
        }

        // Vertical grid lines
        var height = 35 * root.height / 36;
        var yOffset = root.height - height;
        var xOffset = 0;
        for (i = 0; i < gridSize; i++) {
            ctx.moveTo(xOffset + i * gridStep, yOffset);
            ctx.lineTo(xOffset + i * gridStep, height);
        }
        ctx.stroke();//绘制已定义的路径

        // Right ticks
        ctx.strokeStyle = "#666666";//设置或返回用于笔触的颜色、渐变或模式
        ctx.beginPath();//起始一条路径，或重置当前路径
        var xStart = root.width - tickMargin;
        ctx.moveTo(xStart, 0);//把路径移动到画布中的指定点，不创建线条
        ctx.lineTo(xStart, root.height);//添加一个新点，然后在画布中创建从该点到最后指定点的线条
        for (i = 0; i < 12; i++) {
            ctx.moveTo(xStart, root.yGridOffset + i * root.yGridStep);
            ctx.lineTo(root.width, root.yGridOffset + i * root.yGridStep);
        }
        ctx.moveTo(0, root.yGridOffset + 9 * root.yGridStep);
        ctx.lineTo(root.width, root.yGridOffset + 9 * root.yGridStep);
        ctx.closePath();//创建从当前点回到起始点的路径
        ctx.stroke();//绘制已定义的路径
        ctx.restore();//返回之前保存过的路径状态和属性
    }

    // Returns a shortened, readable version of the potentially
    // large volume number.
    function volumeToString(value) {
        if (value < 1000)
            return value;
        var exponent = parseInt(Math.log(value) / Math.log(1000));
        var shortVal = parseFloat(parseFloat(value) / Math.pow(1000, exponent)).toFixed(1);

        // Drop the decimal point on 3-digit values to make it fit
        if (shortVal >= 100.0) {
            shortVal = parseFloat(shortVal).toFixed(0);
        }
        return shortVal + "KMBTG".charAt(exponent - 1);
    }

    function drawScales(ctx, high, low, vol){
        ctx.save();
        ctx.strokeStyle = "#888888";
        ctx.font = "10px Open Sans"
        ctx.beginPath();

        // prices on y-axis
        var x = root.width - tickMargin + 3;
        var priceStep = (high - low) / 9.0;
        for (var i = 0; i < 10; i += 2) {
            var price = parseFloat(high - i * priceStep).toFixed(1);//parseFloat() 函数可解析一个字符串，并返回一个浮点数。
            //该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。
            ctx.text(price, x, root.yGridOffset + i * yGridStep - 2);
        }

        // volume scale
        for (i = 0; i < 3; i++) {
            var volume = volumeToString(vol - (i * (vol/3)));
            ctx.text(volume, x, root.yGridOffset + (i + 9) * yGridStep + 10);
        }

        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }

    function drawPrice(ctx, from, to, color, price, points, highest, lowest){
        ctx.save();
        ctx.globalAlpha = 0.7;
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();

        var end = points.length;

        var range = highest - lowest;
        if (range == 0) {
            range = 1;
        }

        for (var i = 0; i < end; i += pixelSkip) {
            var x = points[i].x;
            var y = points[i][price];
            var h = 9 * yGridStep;

            y = h * (lowest - y)/range + h + yGridOffset;

            if (i == 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
        ctx.restore();
    }

    function drawVolume(ctx, from, to, color, price, points, highest){
        ctx.save();
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.8;
        ctx.lineWidth = 0;
        ctx.beginPath();

        var end = points.length;
        var margin = 0;

        if (activeChart === "month" || activeChart === "week") {
            margin = 8;
            ctx.shadowOffsetX = 4;
            ctx.shadowBlur = 3.5;
            ctx.shadowColor = Qt.darker(color);
        }

        // To match the volume graph with price grid, skip drawing the initial
        // volume of the first day on
        for (var i = 1; i < end; i += pixelSkip) {
            var x = points[i - 1].x;
            var y = points[i][price];
            y = root.height * (y / highest);
            y = 3 * y / 12;
            ctx.fillRect(x, root.height - y + yGridOffset,
                         root.xGridStep - margin, y);
        }

        ctx.stroke();
        ctx.restore();
    }

    function drawError(ctx, msg){
        ctx.save(); //保存当前环境的状态
        ctx.strokeStyle = "#888888"; //设置或返回用于笔触的颜色、渐变或模式
        ctx.font = "24px Open Sans"
        ctx.textAlign = "center"
        ctx.shadowOffsetX = 4;//设置或返回阴影距形状的水平距离
        ctx.shadowOffsetY = 4;//设置或返回阴影距形状的垂直距离
        ctx.shadowBlur = 1.5;//设置或返回用于阴影的模糊级别
        ctx.shadowColor = "#aaaaaa";//设置或返回用于阴影的颜色
        ctx.beginPath();//起始一条路径，或重置当前路径

        ctx.fillText(msg, (root.width - tickMargin) / 2,
                          (root.height - yGridOffset - yGridStep) / 2);

        ctx.closePath();//创建从当前点回到起始点的路径
        ctx.stroke();//绘制已定义的路径
        ctx.restore();//返回之前保存过的路径状态和属性  !!just path and property
    }

    onPaint: {
        //get startData's index during all background data
        numPoints = stockModel.indexOf(dateStart__MS);

        if (gridSize == 0)
            gridSize = numPoints

        var ctx = root.getContext("2d");
        ctx.globalCompositeOperation = "source-over";//设置或返回新图像如何绘制到已有的图像上。默认。在目标图像上显示源图像。
        ctx.lineWidth = 1;

        drawBackground(ctx);//背景

        if (!stockModel.ready) {
            drawError(ctx, "No data available.");
            return;
        }

        var highestPrice = 0;
        var highestVolume = 0;
        var lowestPrice = -1;
        var points = [];
        //找到范围内最大价格、最小价格、最大成交量和最小成交量。作为后续绘图的范围
        //numPoints is the startData's index during all background data
        //pixelSkip is the data skip. default is 1(no skip)
        for (var i = numPoints, j = 0; i >= 0 ; i -= pixelSkip, j += pixelSkip) {
            var price = stockModel.get(i);
            if (parseFloat(highestPrice) < parseFloat(price.high))//parseFloat() 函数可解析一个字符串，并返回一个浮点数。
                //该函数指定字符串中的首个字符是否是数字。如果是，则对字符串进行解析，直到到达数字的末端为止，然后以数字返回该数字，而不是作为字符串。
                highestPrice = price.high;
            if (parseInt(highestVolume, 10) < parseInt(price.volume, 10))
                highestVolume = price.volume;
            if (lowestPrice < 0 || parseFloat(lowestPrice) > parseFloat(price.low))
                lowestPrice = price.low;
            points.push({
                            x: j * xGridStep,
                            open: price.open,
                            close: price.close,
                            high: price.high,
                            low: price.low,
                            volume: price.volume
                        });
        }

        //价格
        if (settings.drawHighPrice)
            drawPrice(ctx, 0, numPoints, settings.highColor, "high", points, highestPrice, lowestPrice);
        if (settings.drawLowPrice)
            drawPrice(ctx, 0, numPoints, settings.lowColor, "low", points, highestPrice, lowestPrice);
        if (settings.drawOpenPrice)
            drawPrice(ctx, 0, numPoints,settings.openColor, "open", points, highestPrice, lowestPrice);
        if (settings.drawClosePrice)
            drawPrice(ctx, 0, numPoints, settings.closeColor, "close", points, highestPrice, lowestPrice);
        //成交量
        drawVolume(ctx, 0, numPoints, settings.volumeColor, "volume", points, highestVolume);
        //坐标值
        drawScales(ctx, highestPrice, lowestPrice, highestVolume);
    }
}
